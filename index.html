<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>Wavelength ‚Äî 2 jugadores</title>
  <style>
    :root{
      --bg: #0b0f17;
      --panel: rgba(255,255,255,.07);
      --panel2: rgba(255,255,255,.10);
      --line: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --shadow: 0 16px 44px rgba(0,0,0,.40);
      --shadow2: 0 18px 60px rgba(0,0,0,.50);
      --radius: 20px;
      --radius2: 26px;
      --focus: 2px solid rgba(120,200,255,.9);

      --p1: #7dd3fc;
      --p2: #a78bfa;

      --w2: rgba(251,191,36,.20);
      --w3: rgba(52,211,153,.22);
      --w4: rgba(125,211,252,.26);

      --anim: 180ms cubic-bezier(.2,.8,.2,1);
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f7fb;
        --panel: rgba(0,0,0,.05);
        --panel2: rgba(0,0,0,.08);
        --line: rgba(0,0,0,.12);
        --text: rgba(0,0,0,.88);
        --muted: rgba(0,0,0,.60);
        --shadow: 0 14px 36px rgba(0,0,0,.14);
        --shadow2: 0 18px 56px rgba(0,0,0,.18);
      }
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(900px 650px at 20% -10%, rgba(125,211,252,.25), transparent 60%),
        radial-gradient(900px 650px at 90% -10%, rgba(167,139,250,.22), transparent 60%),
        radial-gradient(800px 600px at 50% 110%, rgba(52,211,153,.16), transparent 65%),
        var(--bg);
      color: var(--text);
      line-height:1.35;
    }

    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px 14px 32px;
    }

    header{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 14px;
    }
    .brand{ display:flex; align-items:center; gap:10px; }
    .logo{
      width: 42px; height: 42px; border-radius: 16px;
      border:1px solid var(--line);
      background:
        radial-gradient(16px 16px at 30% 30%, rgba(255,255,255,.55), transparent 60%),
        radial-gradient(24px 24px at 70% 35%, rgba(125,211,252,.55), transparent 60%),
        radial-gradient(26px 26px at 45% 75%, rgba(167,139,250,.48), transparent 62%),
        rgba(255,255,255,.06);
      box-shadow: var(--shadow);
    }
    .brand h1{ margin:0; font-size:16px; font-weight:900; letter-spacing:.2px; }
    .brand p{ margin:0; font-size:12px; color: var(--muted); }

    .top-actions{ display:flex; gap:8px; flex-wrap: wrap; align-items:center; }

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.07);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 800;
      font-size: 13px;
      letter-spacing:.15px;
      cursor:pointer;
      transition: transform var(--anim), background var(--anim), border-color var(--anim);
      box-shadow: 0 10px 22px rgba(0,0,0,.16);
    }
    .btn:hover{ background: rgba(255,255,255,.11); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0); }
    .btn:focus-visible{ outline: var(--focus); outline-offset:2px; }
    .btn.primary{
      border-color: rgba(125,211,252,.55);
      background: linear-gradient(180deg, rgba(125,211,252,.20), rgba(255,255,255,.06));
    }
    .btn.ghost{ background: transparent; box-shadow:none; }
    .btn.danger{
      border-color: rgba(251,113,133,.55);
      background: linear-gradient(180deg, rgba(251,113,133,.18), rgba(255,255,255,.06));
    }
    .btn.small{ padding: 8px 10px; border-radius: 12px; font-size: 12px; }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 920px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      border:1px solid var(--line);
      background: linear-gradient(180deg, var(--panel), transparent 140%);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow: clip;
    }
    .card .hd{
      padding: 14px 14px 10px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    .title{ display:flex; flex-direction:column; gap:3px; min-width: 0; }
    .title b{ font-size:14px; letter-spacing:.2px; }
    .title span{ font-size:12px; color: var(--muted); }
    .card .bd{ padding: 14px; }

    .row{ display:flex; align-items:center; gap:10px; flex-wrap: wrap; }
    .col{ display:flex; flex-direction:column; gap:10px; }
    .grow{ flex:1 1 auto; min-width: 220px; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      user-select:none;
      white-space: nowrap;
    }
    .pill strong{ color: var(--text); font-weight: 900; }

    .notice{
      border-radius: 18px;
      border: 1px dashed rgba(125,211,252,.35);
      background: rgba(125,211,252,.08);
      padding: 10px 12px;
      font-size: 12.5px;
      color: var(--muted);
    }

    label{ font-size:12px; color: var(--muted); display:block; margin-bottom:6px; }
    .input, textarea{
      width:100%;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      outline:none;
    }
    .input:focus, textarea:focus{
      border-color: rgba(125,211,252,.55);
      background: rgba(255,255,255,.07);
    }
    textarea{ resize: vertical; min-height: 72px; }

    .hr{ height:1px; background: var(--line); margin: 10px 0; }

    /* ===== Dial (semi-c√≠rculo) ===== */
    .dialWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      justify-items: center;
    }
    .dial{
      width: min(100%, 560px);
      border-radius: 22px;
      border: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: var(--shadow2);
      padding: 14px 12px 10px;
      position: relative;
      overflow: hidden;
    }
    .dial::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(700px 260px at 50% 110%, rgba(255,255,255,.10), transparent 60%),
        radial-gradient(320px 240px at 12% 0%, rgba(125,211,252,.10), transparent 65%),
        radial-gradient(340px 260px at 88% 0%, rgba(167,139,250,.10), transparent 65%);
      opacity:.9;
    }
    .dialInner{ position: relative; z-index: 1; }
    .dialSvg{ width: 100%; height: auto; display:block; }

    .dialLabels{
      display:flex;
      align-items:flex-end;
      justify-content: space-between;
      gap: 10px;
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .dialLabels .side{
      max-width: 46%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .dialLabels .mid{ font-weight: 900; color: rgba(255,255,255,.55); }
    @media (prefers-color-scheme: light){
      .dialLabels .mid{ color: rgba(0,0,0,.45); }
    }

    .legend{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content:center;
      font-size: 12px;
      color: var(--muted);
    }
    .lg{
      display:inline-flex;
      gap: 8px;
      align-items:center;
      padding: 6px 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
    }
    .sw{ width: 12px; height: 12px; border-radius: 4px; display:inline-block; }
    .sw.w2{ background: rgba(251,191,36,.30); }
    .sw.w3{ background: rgba(52,211,153,.30); }
    .sw.w4{ background: rgba(125,211,252,.36); }

    .sliderRow{
      width: min(100%, 560px);
      display:flex;
      flex-direction: column;
      gap: 8px;
      margin: 0 auto;
    }
    input[type="range"]{ width:100%; accent-color: #7dd3fc; }
    .numRow{
      display:flex; justify-content: space-between; align-items:center;
      font-size: 12px; color: var(--muted);
    }
    .numRow b{ color: var(--text); font-weight: 900; }

    /* Sidebar */
    .playerBox{
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 8px;
    }
    .playerTop{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .nameRow{ display:flex; align-items:center; gap:10px; min-width:0; }
    .dot{ width:10px; height:10px; border-radius:50%; background: var(--p1); }
    .dot.p2{ background: var(--p2); }
    .pname{ font-size: 13px; font-weight: 900; white-space: nowrap; overflow:hidden; text-overflow: ellipsis; }
    .pscore{ font-size: 24px; font-weight: 950; letter-spacing:.2px; }
    .role{
      font-size: 12px; color: var(--muted);
      display:flex; justify-content: space-between; align-items:center; gap: 10px;
    }
    .role b{ color: var(--text); }

    /* Modal */
    .modalBackdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 50;
    }
    .modalBackdrop.show{ display:flex; }
    .modal{
      width:min(820px, 100%);
      max-height: min(86vh, 720px);
      overflow:auto;
      border-radius: 22px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      box-shadow: var(--shadow2);
    }
    .modal .mhd{
      padding: 14px 14px 10px;
      display:flex; align-items:center; justify-content: space-between; gap:10px;
      border-bottom:1px solid var(--line);
      position: sticky; top:0;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(0,0,0,.22), transparent);
    }
    @media (prefers-color-scheme: light){
      .modal .mhd{ background: linear-gradient(180deg, rgba(255,255,255,.72), rgba(255,255,255,.24)); }
    }
    .modal .mbd{ padding: 14px; }
    .modal h3{ margin:10px 0 6px; font-size: 13px; }
    .modal p, .modal li{ font-size: 12.5px; color: var(--muted); }
    .modal ul{ margin: 8px 0 0 18px; padding: 0; }

    /* Toast */
    .toast{
      position: fixed;
      left:50%; bottom:18px;
      transform: translateX(-50%);
      max-width: min(760px, calc(100% - 24px));
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.55);
      color: rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow2);
      display:none;
      z-index: 80;
      font-size: 12.5px;
    }
    @media (prefers-color-scheme: light){
      .toast{ background: rgba(255,255,255,.84); color: rgba(0,0,0,.88); }
    }
    .toast.show{ display:block; animation: popIn 220ms cubic-bezier(.2,.8,.2,1); }
    @keyframes popIn{
      from{ transform: translateX(-50%) translateY(8px); opacity:0; }
      to{ transform: translateX(-50%) translateY(0); opacity:1; }
    }

    @media (prefers-reduced-motion: reduce){
      *{ transition:none !important; animation:none !important; }
    }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Wavelength para dos jugadores">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Wavelength</h1>
          <p>2 jugadores ‚Äî sin modos, listo para jugar.</p>
        </div>
      </div>
      <div class="top-actions">
        <button class="btn ghost small" id="btnRules" aria-haspopup="dialog" aria-controls="modalRules">Instrucciones</button>
        <button class="btn small" id="btnFullscreen">Pantalla completa</button>
        <button class="btn danger small" id="btnReset">Reset</button>
      </div>
    </header>

    <main class="grid">
      <!-- Main -->
      <section class="card" aria-label="Panel principal">
        <div class="hd">
          <div class="title">
            <b id="phaseTitle">Cargando‚Ä¶</b>
            <span id="phaseSubtitle">‚Äî</span>
          </div>
          <div class="row">
            <span class="pill" id="pillTurn"><strong>Turno:</strong> ‚Äî</span>
            <span class="pill" id="pillGoal"><strong>Objetivo:</strong> 10</span>
          </div>
        </div>
        <div class="bd" id="mainArea"></div>
      </section>

      <!-- Sidebar -->
      <aside class="card" aria-label="Marcador">
        <div class="hd">
          <div class="title">
            <b>Marcador</b>
            <span id="scoreSubtitle">Primero a 10 puntos</span>
          </div>
          <div class="row">
            <button class="btn small" id="btnPass">Pasar dispositivo</button>
          </div>
        </div>
        <div class="bd">
          <div class="col">
            <div class="playerBox">
              <div class="playerTop">
                <div class="nameRow">
                  <span class="dot" aria-hidden="true"></span>
                  <div class="pname" id="p1Name">Jugador 1</div>
                </div>
                <div class="pscore" id="p1Score">0</div>
              </div>
              <div class="role">
                <span>Rol: <b id="p1Role">‚Äî</b></span>
                <span class="pill"><strong>ID:</strong> 1</span>
              </div>
            </div>

            <div class="playerBox">
              <div class="playerTop">
                <div class="nameRow">
                  <span class="dot p2" aria-hidden="true"></span>
                  <div class="pname" id="p2Name">Jugador 2</div>
                </div>
                <div class="pscore" id="p2Score">0</div>
              </div>
              <div class="role">
                <span>Rol: <b id="p2Role">‚Äî</b></span>
                <span class="pill"><strong>ID:</strong> 2</span>
              </div>
            </div>

            <div class="hr"></div>

            <div class="legend" aria-label="Leyenda de puntuaci√≥n">
              <span class="lg"><span class="sw w4"></span>4 pts ¬±5</span>
              <span class="lg"><span class="sw w3"></span>3 pts ¬±12</span>
              <span class="lg"><span class="sw w2"></span>2 pts ¬±20</span>
            </div>

            <div class="notice">
              En ‚ÄúPs√≠quico‚Äù se muestra el objetivo. En ‚ÄúAdivinar‚Äù y ‚ÄúRevelaci√≥n‚Äù solo lo ver√©is cuando toque.
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <!-- Rules Modal -->
  <div class="modalBackdrop" id="modalRules" role="dialog" aria-modal="true" aria-labelledby="modalRulesTitle">
    <div class="modal">
      <div class="mhd">
        <b id="modalRulesTitle">Instrucciones (2 jugadores)</b>
        <button class="btn small" id="btnCloseRules">Cerrar</button>
      </div>
      <div class="mbd">
        <h3>Flujo</h3>
        <ul>
          <li><b>Nueva ronda:</b> carta (dos extremos) + pista (opcional para memoria).</li>
          <li><b>Ps√≠quico:</b> un jugador ve el objetivo (0‚Äì100) y dice una pista de una sola idea.</li>
          <li><b>Adivinar:</b> el otro jugador mueve el dial (0‚Äì100) y bloquea.</li>
          <li><b>Revelaci√≥n:</b> se muestra el objetivo y se punt√∫a. Luego se intercambian roles.</li>
        </ul>

        <h3>Puntuaci√≥n</h3>
        <ul>
          <li>¬±5: <b>4 puntos</b></li>
          <li>¬±12: <b>3 puntos</b></li>
          <li>¬±20: <b>2 puntos</b></li>
          <li>Fuera: <b>0 puntos</b></li>
        </ul>

        <h3>Reglas de pista</h3>
        <ul>
          <li>Una sola idea (no dos pistas).</li>
          <li>No uses n√∫meros/porcentajes.</li>
          <li>No uses las palabras de la carta ni sin√≥nimos obvios.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    (() => {
      "use strict";

      // ===== Cards (>=60) =====
      const CARDS = [
        { left:"Fr√≠o", right:"Caliente" },
        { left:"Aburrido", right:"Emocionante" },
        { left:"Inofensivo", right:"Peligroso" },
        { left:"Com√∫n", right:"Raro" },
        { left:"D√©bil", right:"Fuerte" },
        { left:"Simple", right:"Complejo" },
        { left:"Tradicional", right:"Innovador" },
        { left:"Caro", right:"Barato" },
        { left:"Serio", right:"C√≥mico" },
        { left:"Ordenado", right:"Ca√≥tico" },
        { left:"Ego√≠sta", right:"Altruista" },
        { left:"Lento", right:"R√°pido" },
        { left:"Seguro", right:"Arriesgado" },
        { left:"Formal", right:"Informal" },
        { left:"Amigable", right:"Hostil" },
        { left:"Sutil", right:"Exagerado" },
        { left:"F√°cil", right:"Dif√≠cil" },
        { left:"De mal gusto", right:"Elegante" },
        { left:"Relajante", right:"Estresante" },
        { left:"Predecible", right:"Impredecible" },
        { left:"Infantil", right:"Adulto" },
        { left:"Moderno", right:"Retro" },
        { left:"Realista", right:"Fant√°stico" },
        { left:"Optimista", right:"Pesimista" },
        { left:"Honesto", right:"Enga√±oso" },
        { left:"Conservador", right:"Rebelde" },
        { left:"Silencioso", right:"Ruidoso" },
        { left:"√çntimo", right:"P√∫blico" },
        { left:"Casual", right:"Solemne" },
        { left:"Suave", right:"Brusco" },
        { left:"Delicado", right:"Robusto" },
        { left:"Abstracto", right:"Concreto" },
        { left:"Limpio", right:"Sucio" },
        { left:"Natural", right:"Artificial" },
        { left:"Agradable", right:"Desagradable" },
        { left:"Racional", right:"Emocional" },
        { left:"Amable", right:"Cruel" },
        { left:"Flexible", right:"R√≠gido" },
        { left:"Minimalista", right:"Recargado" },
        { left:"Local", right:"Global" },
        { left:"Cl√°sico", right:"Vanguardista" },
        { left:"Tierno", right:"Intimidante" },
        { left:"Pr√°ctico", right:"Impr√°ctico" },
        { left:"Popular", right:"De nicho" },
        { left:"Cotidiano", right:"√âpico" },
        { left:"Atemporal", right:"De moda" },
        { left:"Aire libre", right:"Interior" },
        { left:"Individual", right:"En equipo" },
        { left:"Aventurero", right:"Cauteloso" },
        { left:"Directo", right:"Ambiguo" },
        { left:"Atractivo", right:"Repulsivo" },
        { left:"Futurista", right:"Antiguo" },
        { left:"Eficiente", right:"Ineficiente" },
        { left:"Duro", right:"Blando" },
        { left:"Sincero", right:"Diplom√°tico" },
        { left:"Exclusivo", right:"Inclusivo" },
        { left:"Intenso", right:"Ligero" },
        { left:"Fr√°gil", right:"Resistente" },
        { left:"Estable", right:"Vol√°til" },
        { left:"Met√≥dico", right:"Impulsivo" },
        { left:"Sano", right:"Indulgente" },
        { left:"L√≥gico", right:"Intuitivo" },
        { left:"Pulido", right:"Desali√±ado" },
        { left:"Cercano", right:"Distante" },
        { left:"Profesional", right:"Amateur" },
        { left:"Humilde", right:"Presumido" },
        { left:"Confiable", right:"Inestable" },
        { left:"Cient√≠fico", right:"M√≠stico" },
        { left:"Transparente", right:"Opaco" },
        { left:"Carism√°tico", right:"Insulso" },
        { left:"Valiente", right:"Cobarde" },
        { left:"Curioso", right:"Indiferente" },
        { left:"Creativo", right:"Convencional" },
      ];

      // ===== Constants / Pure functions =====
      const GOAL = 10;
      const WEDGES = { w4: 5, w3: 12, w2: 20 };

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

      function valueToDeg(v){ // 0..100 => -90..90
        const x = clamp(v, 0, 100) / 100;
        return -90 + x * 180;
      }
      function randomTarget(){ return rnd(0, 100); }

      function scoreGuess(target, guess){
        const d = Math.abs(clamp(target,0,100) - clamp(guess,0,100));
        if (d <= WEDGES.w4) return { pts: 4, band: "CENTER" };
        if (d <= WEDGES.w3) return { pts: 3, band: "NEAR" };
        if (d <= WEDGES.w2) return { pts: 2, band: "FAR" };
        return { pts: 0, band: "MISS" };
      }

      // ===== Minimal state machine =====
      const STATES = Object.freeze({
        SETUP: "SETUP",
        ROUND: "ROUND",           // shows card + start psychic
        PSYCHIC: "PSYCHIC",       // target visible
        GUESS: "GUESS",           // slider, no target
        REVEAL: "REVEAL",         // both visible + scoring
        OVER: "OVER"
      });

      const $ = (sel, root=document) => root.querySelector(sel);

      const els = {
        main: $("#mainArea"),
        phaseTitle: $("#phaseTitle"),
        phaseSubtitle: $("#phaseSubtitle"),
        pillTurn: $("#pillTurn"),
        pillGoal: $("#pillGoal"),
        scoreSubtitle: $("#scoreSubtitle"),

        p1Name: $("#p1Name"),
        p2Name: $("#p2Name"),
        p1Score: $("#p1Score"),
        p2Score: $("#p2Score"),
        p1Role: $("#p1Role"),
        p2Role: $("#p2Role"),

        btnRules: $("#btnRules"),
        modalRules: $("#modalRules"),
        btnCloseRules: $("#btnCloseRules"),

        btnFullscreen: $("#btnFullscreen"),
        btnReset: $("#btnReset"),
        btnPass: $("#btnPass"),
        toast: $("#toast")
      };

      function showToast(msg, ms=2300){
        els.toast.textContent = msg;
        els.toast.classList.add("show");
        clearTimeout(showToast._t);
        showToast._t = setTimeout(() => els.toast.classList.remove("show"), ms);
      }

      function openModal(m){ m.classList.add("show"); m.querySelector("button")?.focus(); }
      function closeModal(m){ m.classList.remove("show"); }

      // ===== Game store =====
      const store = {
        state: STATES.SETUP,
        goal: GOAL,
        players: [
          { name: "Jugador 1", score: 0 },
          { name: "Jugador 2", score: 0 }
        ],
        psychicIndex: 0, // 0 or 1
        card: null,
        clue: "",
        target: null,
        guess: 50,
        scored: null,
        deck: [],
        used: new Set()
      };

      function buildDeck(){
        store.deck = Array.from({length: CARDS.length}, (_,i)=>i);
        for (let i=store.deck.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [store.deck[i], store.deck[j]] = [store.deck[j], store.deck[i]];
        }
      }

      function drawCard(){
        if (store.deck.length === 0) buildDeck();
        const idx = store.deck.pop();
        return CARDS[idx];
      }

      function resetRound(){
        store.card = drawCard();
        store.clue = "";
        store.target = null;
        store.guess = 50;
        store.scored = null;
      }

      function setPhase(title, subtitle){
        els.phaseTitle.textContent = title;
        els.phaseSubtitle.textContent = subtitle;
      }

      function renderSidebar(){
        els.pillGoal.innerHTML = `<strong>Objetivo:</strong> ${store.goal}`;
        const psychic = store.psychicIndex;
        const guesser = 1 - psychic;

        els.p1Name.textContent = store.players[0].name;
        els.p2Name.textContent = store.players[1].name;
        els.p1Score.textContent = store.players[0].score;
        els.p2Score.textContent = store.players[1].score;

        const roles = (store.state === STATES.SETUP || store.state === STATES.OVER)
          ? ["‚Äî","‚Äî"]
          : [
              psychic === 0 ? "Ps√≠quico" : "Adivina",
              psychic === 1 ? "Ps√≠quico" : "Adivina"
            ];

        els.p1Role.textContent = roles[0];
        els.p2Role.textContent = roles[1];

        const turnText = (store.state === STATES.SETUP || store.state === STATES.OVER)
          ? "‚Äî"
          : `${store.players[psychic].name} (Ps√≠quico)`;
        els.pillTurn.innerHTML = `<strong>Turno:</strong> ${turnText}`;

        els.scoreSubtitle.textContent = `Primero a ${store.goal} puntos`;
      }

      function escapeHtml(s){
        return String(s).replace(/[&<>"']/g, m => ({
          "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
        }[m]));
      }

      // ===== Dial renderer =====
      function dialHTML({ left, right, showTarget, target, showGuess, guess }){
        const tDeg = valueToDeg(target ?? 50);
        const gDeg = valueToDeg(guess ?? 50);

        // SVG geometry: semicircle radius 160 centered at (200,200) in viewBox 0 0 400 240
        // Arc from left (40,200) to right (360,200) with radius 160
        // Needle anchored at (200,200)
        const showWedges = !!showTarget;

        return `
          <div class="dial">
            <div class="dialInner">
              <svg class="dialSvg" viewBox="0 0 400 250" aria-label="Dial Wavelength" role="img">
                <defs>
                  <filter id="softShadow" x="-50%" y="-50%" width="200%" height="200%">
                    <feDropShadow dx="0" dy="8" stdDeviation="8" flood-color="rgba(0,0,0,.35)"/>
                  </filter>
                  <linearGradient id="needleGrad" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stop-color="rgba(255,255,255,.92)"/>
                    <stop offset="100%" stop-color="rgba(255,255,255,.10)"/>
                  </linearGradient>
                  <linearGradient id="targetGrad" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stop-color="rgba(125,211,252,.98)"/>
                    <stop offset="100%" stop-color="rgba(125,211,252,.14)"/>
                  </linearGradient>
                </defs>

                <!-- Base arc -->
                <path d="M 40 200 A 160 160 0 0 1 360 200"
                      fill="none" stroke="rgba(255,255,255,.35)" stroke-width="10" stroke-linecap="round"/>
                <!-- Ticks -->
                ${Array.from({length: 21}, (_,i)=>{
                  const v = i*5; // 0..100
                  const a = valueToDeg(v) * Math.PI/180;
                  const cx = 200, cy = 200;
                  const r1 = 150, r2 = (i%5===0) ? 132 : 140;
                  const x1 = cx + Math.cos(a) * r1;
                  const y1 = cy + Math.sin(a) * r1;
                  const x2 = cx + Math.cos(a) * r2;
                  const y2 = cy + Math.sin(a) * r2;
                  const sw = (i%5===0) ? 2.2 : 1.2;
                  const op = (i%5===0) ? .26 : .18;
                  return `<line x1="${x1.toFixed(2)}" y1="${y1.toFixed(2)}" x2="${x2.toFixed(2)}" y2="${y2.toFixed(2)}" stroke="rgba(255,255,255,${op})" stroke-width="${sw}" />`;
                }).join("")}

                <!-- Wedges centered on target (only when target visible) -->
                ${showWedges ? wedgesSVG(target ?? 50) : ""}

                <!-- Target needle (thin) -->
                ${showTarget ? `
                  <g transform="rotate(${tDeg} 200 200)" filter="url(#softShadow)">
                    <rect x="199" y="58" width="2" height="142" rx="1" fill="url(#targetGrad)"></rect>
                  </g>
                ` : ""}

                <!-- Guess needle -->
                ${showGuess ? `
                  <g transform="rotate(${gDeg} 200 200)" filter="url(#softShadow)">
                    <rect x="198" y="52" width="4" height="148" rx="2" fill="url(#needleGrad)"></rect>
                  </g>
                  <circle cx="200" cy="200" r="12" fill="rgba(255,255,255,.12)" stroke="rgba(255,255,255,.25)"></circle>
                ` : `
                  <circle cx="200" cy="200" r="12" fill="rgba(255,255,255,.08)" stroke="rgba(255,255,255,.18)"></circle>
                `}
              </svg>

              <div class="dialLabels" aria-hidden="true">
                <div class="side">${escapeHtml(left)}</div>
                <div class="mid">${showTarget ? `Obj: ${target}` : `0‚Äì100`}</div>
                <div class="side" style="text-align:right;">${escapeHtml(right)}</div>
              </div>
            </div>
          </div>
        `;
      }

      function wedgesSVG(center){
        const cDeg = valueToDeg(center);
        // We approximate wedges as translucent sectors with different radii.
        // We'll draw 3 sectors (w2, w3, w4) with same angle spans based on wedge radii (in "value space").
        // Convert wedge "value" to degrees: 180deg span across 100 values => 1.8deg per value.
        const degPerVal = 180 / 100;
        const a2 = WEDGES.w2 * degPerVal;
        const a3 = WEDGES.w3 * degPerVal;
        const a4 = WEDGES.w4 * degPerVal;

        // Sector path helper centered at (200,200)
        const sector = (radius, halfAngleDeg, fill) => {
          const cx=200, cy=200;
          const start = (cDeg - halfAngleDeg) * Math.PI/180;
          const end   = (cDeg + halfAngleDeg) * Math.PI/180;

          const x1 = cx + Math.cos(start)*radius;
          const y1 = cy + Math.sin(start)*radius;
          const x2 = cx + Math.cos(end)*radius;
          const y2 = cy + Math.sin(end)*radius;

          const largeArc = (halfAngleDeg*2) > 180 ? 1 : 0;
          return `
            <path d="M ${cx} ${cy}
                     L ${x1.toFixed(2)} ${y1.toFixed(2)}
                     A ${radius} ${radius} 0 ${largeArc} 1 ${x2.toFixed(2)} ${y2.toFixed(2)}
                     Z"
                  fill="${fill}" />
          `;
        };

        // radii tuned to look like the physical wedge window
        return `
          ${sector(160, a2, "var(--w2)")}
          ${sector(142, a3, "var(--w3)")}
          ${sector(120, a4, "var(--w4)")}
        `;
      }

      // ===== Views =====
      function render(){
        renderSidebar();
        const s = store.state;

        if (s === STATES.SETUP){
          setPhase("Listo para jugar", "Pon nombres (opcional) y pulsa Empezar.");
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="row">
                <div class="grow">
                  <label for="inpP1">Nombre Jugador 1</label>
                  <input id="inpP1" class="input" value="${escapeHtml(store.players[0].name)}" />
                </div>
                <div class="grow">
                  <label for="inpP2">Nombre Jugador 2</label>
                  <input id="inpP2" class="input" value="${escapeHtml(store.players[1].name)}" />
                </div>
              </div>

              <div class="notice">
                <b>C√≥mo se juega:</b> el Ps√≠quico ve el objetivo y da una pista. El otro ajusta el dial. Se alternan roles cada ronda.
              </div>

              ${dialHTML({
                left:"Extremo izquierdo",
                right:"Extremo derecho",
                showTarget:false,
                target:null,
                showGuess:true,
                guess: 50
              })}

              <div class="row" style="justify-content:space-between;">
                <span class="pill"><strong>Cartas:</strong> ${CARDS.length}</span>
                <button class="btn primary" id="btnStart">Empezar</button>
              </div>
            </div>
          `;

          $("#inpP1").addEventListener("input", (e)=>{ store.players[0].name = (e.target.value||"").trim() || "Jugador 1"; renderSidebar(); });
          $("#inpP2").addEventListener("input", (e)=>{ store.players[1].name = (e.target.value||"").trim() || "Jugador 2"; renderSidebar(); });

          $("#btnStart").addEventListener("click", () => {
            store.players[0].score = 0;
            store.players[1].score = 0;
            store.psychicIndex = 0; // empieza jugador 1
            buildDeck();
            resetRound();
            store.state = STATES.ROUND;
            showToast("Ronda 1: el Ps√≠quico prepara la pista.");
            render();
          });
          return;
        }

        if (s === STATES.ROUND){
          const psychic = store.psychicIndex;
          setPhase("Nueva ronda", `${store.players[psychic].name} es Ps√≠quico. Selecciona carta y (opcional) escribe la pista para recordarla.`);
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="row" style="justify-content:space-between; align-items:flex-start;">
                <div class="col" style="gap:6px;">
                  <b style="font-size:14px;">Carta</b>
                  <span class="pill"><strong>${escapeHtml(store.card.left)}</strong> ‚Äî <strong>${escapeHtml(store.card.right)}</strong></span>
                </div>
                <div class="row">
                  <button class="btn" id="btnNewCard">Otra carta</button>
                </div>
              </div>

              ${dialHTML({
                left: store.card.left,
                right: store.card.right,
                showTarget:false,
                target:null,
                showGuess:true,
                guess: 50
              })}

              <div class="row">
                <div class="grow">
                  <label for="inpClue">Pista (opcional, se mostrar√° tras la revelaci√≥n)</label>
                  <input id="inpClue" class="input" value="${escapeHtml(store.clue)}" placeholder="Ej: ‚Äútostadora‚Äù, ‚Äúdomingo de resaca‚Äù‚Ä¶"/>
                </div>
              </div>

              <div class="row" style="justify-content:space-between;">
                <button class="btn" id="btnPassToPsychic">Ir a Ps√≠quico (mostrar objetivo)</button>
                <button class="btn primary" id="btnGoPsychic">Estoy listo</button>
              </div>
            </div>
          `;

          $("#btnNewCard").addEventListener("click", () => {
            resetRound();
            showToast("Carta nueva.");
            render();
          });

          $("#inpClue").addEventListener("input", (e)=>{
            store.clue = (e.target.value||"").trim().slice(0, 140);
          });

          $("#btnPassToPsychic").addEventListener("click", () => {
            showToast("‚ö†Ô∏è Solo el Ps√≠quico debe mirar ahora.");
          });

          $("#btnGoPsychic").addEventListener("click", () => {
            store.target = randomTarget();
            store.state = STATES.PSYCHIC;
            showToast("Objetivo generado. Solo el Ps√≠quico mira.");
            render();
          });
          return;
        }

        if (s === STATES.PSYCHIC){
          const psychic = store.psychicIndex;
          setPhase("Ps√≠quico", `${store.players[psychic].name}: mira el objetivo y di la pista. Luego oculta y pasa el dispositivo.`);
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="notice">
                <b>Solo el Ps√≠quico</b>. No uses n√∫meros. Una sola idea. Cuando termines, pulsa <b>Ocultar objetivo</b>.
              </div>

              ${dialHTML({
                left: store.card.left,
                right: store.card.right,
                showTarget:true,
                target: store.target,
                showGuess:false,
                guess: store.guess
              })}

              <div class="row">
                <div class="grow">
                  <label for="inpClue2">Pista (opcional, para recordarla)</label>
                  <input id="inpClue2" class="input" value="${escapeHtml(store.clue)}" placeholder="(Opcional) escribe la pista que has dicho"/>
                </div>
              </div>

              <div class="row" style="justify-content:space-between;">
                <button class="btn" id="btnBackRound">Volver</button>
                <button class="btn primary" id="btnHide">Ocultar objetivo / Pasar al otro jugador</button>
              </div>
            </div>
          `;

          $("#inpClue2").addEventListener("input", (e)=>{
            store.clue = (e.target.value||"").trim().slice(0, 140);
          });

          $("#btnBackRound").addEventListener("click", () => {
            if (!confirm("¬øVolver a Nueva ronda? Se regenerar√° el objetivo al volver a Ps√≠quico.")) return;
            store.target = null;
            store.state = STATES.ROUND;
            render();
          });

          $("#btnHide").addEventListener("click", () => {
            store.state = STATES.GUESS;
            showToast("Ahora adivina el otro jugador (sin objetivo).");
            render();
          });
          return;
        }

        if (s === STATES.GUESS){
          const psychic = store.psychicIndex;
          const guesser = 1 - psychic;
          setPhase("Adivinar", `${store.players[guesser].name}: ajusta el dial (0‚Äì100) y bloquea tu respuesta.`);
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="notice">
                Objetivo oculto. Ajusta la posici√≥n. Cuando est√©s seguro, bloquea.
              </div>

              ${dialHTML({
                left: store.card.left,
                right: store.card.right,
                showTarget:false,
                target:null,
                showGuess:true,
                guess: store.guess
              })}

              <div class="sliderRow">
                <label for="rngGuess">Posici√≥n (0‚Äì100)</label>
                <input id="rngGuess" type="range" min="0" max="100" value="${store.guess}" aria-label="Selector de posici√≥n"/>
                <div class="numRow">
                  <span>0</span>
                  <span>Actual: <b id="gVal">${store.guess}</b></span>
                  <span>100</span>
                </div>
              </div>

              <div class="row" style="justify-content:space-between;">
                <button class="btn" id="btnBackPsychic">Volver (Ps√≠quico)</button>
                <button class="btn primary" id="btnLock">Bloquear y revelar</button>
              </div>
            </div>
          `;

          const rng = $("#rngGuess");
          const gVal = $("#gVal");

          rng.addEventListener("input", () => {
            store.guess = clamp(parseInt(rng.value,10), 0, 100);
            gVal.textContent = store.guess;
            // re-render dial only (cheap full render is ok too)
            render();
            store.state = STATES.GUESS; // keep
          });

          $("#btnBackPsychic").addEventListener("click", () => {
            if (!confirm("¬øVolver a Ps√≠quico? Aseg√∫rate de que solo el Ps√≠quico mire.")) return;
            store.state = STATES.PSYCHIC;
            render();
          });

          $("#btnLock").addEventListener("click", () => {
            if (!confirm(`¬øBloquear ${store.guess}?`)) return;
            store.scored = scoreGuess(store.target, store.guess);
            store.state = STATES.REVEAL;
            render();
          });
          return;
        }

        if (s === STATES.REVEAL){
          const psychic = store.psychicIndex;
          const guesser = 1 - psychic;

          const pts = store.scored?.pts ?? 0;
          setPhase("Revelaci√≥n", `Objetivo: ${store.target} ¬∑ Posici√≥n: ${store.guess} ¬∑ +${pts} puntos para ${store.players[guesser].name}`);

          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              ${dialHTML({
                left: store.card.left,
                right: store.card.right,
                showTarget:true,
                target: store.target,
                showGuess:true,
                guess: store.guess
              })}

              <div class="row">
                <span class="pill"><strong>Objetivo:</strong> ${store.target}</span>
                <span class="pill"><strong>Posici√≥n:</strong> ${store.guess}</span>
                <span class="pill"><strong>Puntos:</strong> +${pts}</span>
              </div>

              <div class="notice">
                <b>Carta:</b> ${escapeHtml(store.card.left)} ‚Äî ${escapeHtml(store.card.right)}<br/>
                <b>Pista:</b> ${escapeHtml(store.clue || "‚Äî")}
              </div>

              <div class="row" style="justify-content:space-between;">
                <button class="btn" id="btnBackGuess">Volver (Adivinar)</button>
                <button class="btn primary" id="btnNext">Siguiente ronda (cambiar roles)</button>
              </div>
            </div>
          `;

          $("#btnBackGuess").addEventListener("click", () => {
            if (!confirm("¬øVolver a Adivinar? Mantendr√°s el mismo objetivo.")) return;
            store.state = STATES.GUESS;
            render();
          });

          $("#btnNext").addEventListener("click", () => {
            // En 2 jugadores, lo m√°s limpio es puntuar al adivinador (quien toma decisi√≥n).
            store.players[guesser].score += pts;

            // Win?
            if (store.players[0].score >= store.goal || store.players[1].score >= store.goal){
              store.state = STATES.OVER;
              render();
              showToast("Fin de partida.");
              return;
            }

            // Swap roles
            store.psychicIndex = 1 - store.psychicIndex;

            // Next round
            resetRound();
            store.state = STATES.ROUND;
            showToast("Roles cambiados. Nueva ronda.");
            render();
          });
          return;
        }

        if (s === STATES.OVER){
          const s1 = store.players[0].score;
          const s2 = store.players[1].score;
          const winner = s1 === s2 ? "Empate" : (s1 > s2 ? store.players[0].name : store.players[1].name);

          setPhase("Fin de partida", winner === "Empate" ? "Empate." : `Ganador: ${winner}`);
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="notice">
                <b style="font-size:14px;">Resultado</b><br/>
                <div style="margin-top:10px" class="row">
                  <span class="pill"><strong>${escapeHtml(store.players[0].name)}:</strong> ${s1}</span>
                  <span class="pill"><strong>${escapeHtml(store.players[1].name)}:</strong> ${s2}</span>
                </div>
              </div>

              ${dialHTML({
                left:"‚Äî",
                right:"‚Äî",
                showTarget:false,
                target:null,
                showGuess:true,
                guess: 50
              })}

              <div class="row" style="justify-content:center;">
                <button class="btn primary" id="btnPlayAgain">Jugar otra vez</button>
                <button class="btn" id="btnBackSetup">Cambiar nombres</button>
              </div>
            </div>
          `;

          $("#btnPlayAgain").addEventListener("click", () => {
            store.players[0].score = 0;
            store.players[1].score = 0;
            store.psychicIndex = 0;
            buildDeck();
            resetRound();
            store.state = STATES.ROUND;
            showToast("Nueva partida.");
            render();
          });

          $("#btnBackSetup").addEventListener("click", () => {
            store.state = STATES.SETUP;
            render();
          });
          return;
        }
      }

      // ===== Global controls =====
      els.btnRules.addEventListener("click", () => openModal(els.modalRules));
      els.btnCloseRules.addEventListener("click", () => closeModal(els.modalRules));
      els.modalRules.addEventListener("click", (e)=>{ if (e.target === els.modalRules) closeModal(els.modalRules); });
      window.addEventListener("keydown", (e)=>{ if (e.key === "Escape") closeModal(els.modalRules); });

      els.btnFullscreen.addEventListener("click", async () => {
        try{
          if (!document.fullscreenElement){
            await document.documentElement.requestFullscreen();
            showToast("Pantalla completa.");
          } else {
            await document.exitFullscreen();
            showToast("Salir de pantalla completa.");
          }
        } catch {
          showToast("Pantalla completa no disponible.");
        }
      });

      els.btnPass.addEventListener("click", () => {
        const msg =
          store.state === STATES.PSYCHIC ? "üì± Solo el PS√çQUICO mira ahora." :
          store.state === STATES.GUESS ? "üì± Ahora adivina el otro jugador (sin objetivo)." :
          store.state === STATES.REVEAL ? "üì± Revelaci√≥n: puede mirar todo el mundo." :
          "üì± Estado actual listo.";
        showToast(msg, 2600);
      });

      els.btnReset.addEventListener("click", () => {
        if (!confirm("¬øReset total? Reinicia puntuaci√≥n y vuelve al inicio.")) return;
        store.players[0].score = 0;
        store.players[1].score = 0;
        store.psychicIndex = 0;
        store.card = null;
        store.clue = "";
        store.target = null;
        store.guess = 50;
        store.scored = null;
        store.deck = [];
        store.used = new Set();
        store.state = STATES.SETUP;
        showToast("Reset completado.");
        render();
      });

      // ===== Boot =====
      // Deja la app en SETUP y renderiza. Esto garantiza que al abrir se vea UI y el dial.
      render();
    })();
  </script>
</body>
</html>
