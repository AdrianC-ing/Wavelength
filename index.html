<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>Wavelength ‚Äî 2 jugadores</title>
  <style>
    :root{
      --bg: #0b0f17;
      --panel: rgba(255,255,255,.07);
      --line: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --shadow: 0 16px 44px rgba(0,0,0,.40);
      --shadow2: 0 18px 60px rgba(0,0,0,.50);
      --radius2: 26px;
      --focus: 2px solid rgba(120,200,255,.9);
      --anim: 180ms cubic-bezier(.2,.8,.2,1);

      --p1: #7dd3fc;
      --p2: #a78bfa;

      /* Dial physical-ish */
      --dialFace: #efe9dc;      /* beige */
      --dialFaceEdge: rgba(0,0,0,.08);
      --dialWindow2: #ffb44d;   /* 2 pts */
      --dialWindow3: #ff7a3c;   /* 3 pts */
      --dialWindow4: #6bb6ff;   /* 4 pts */
      --dialNeedle: #cf3b3b;    /* red */
      --dialNeedle2: rgba(255,255,255,.55);
      --dialCenter: #c73737;    /* red knob */
      --dialTextDark: rgba(0,0,0,.78);
      --dialTextLight: rgba(255,255,255,.88);
    }

    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f7fb;
        --panel: rgba(0,0,0,.05);
        --line: rgba(0,0,0,.12);
        --text: rgba(0,0,0,.88);
        --muted: rgba(0,0,0,.60);
        --shadow: 0 14px 36px rgba(0,0,0,.14);
        --shadow2: 0 18px 56px rgba(0,0,0,.18);
      }
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(900px 650px at 20% -10%, rgba(125,211,252,.25), transparent 60%),
        radial-gradient(900px 650px at 90% -10%, rgba(167,139,250,.22), transparent 60%),
        radial-gradient(800px 600px at 50% 110%, rgba(52,211,153,.14), transparent 65%),
        var(--bg);
      color: var(--text);
      line-height:1.35;
    }

    .wrap{ max-width: 1100px; margin: 0 auto; padding: 16px 14px 32px; }

    header{
      display:flex; align-items:center; justify-content: space-between;
      gap: 10px; flex-wrap: wrap; margin-bottom: 14px;
    }
    .brand{ display:flex; align-items:center; gap:10px; }
    .logo{
      width: 42px; height: 42px; border-radius: 16px;
      border:1px solid var(--line);
      background:
        radial-gradient(16px 16px at 30% 30%, rgba(255,255,255,.55), transparent 60%),
        radial-gradient(24px 24px at 70% 35%, rgba(125,211,252,.55), transparent 60%),
        radial-gradient(26px 26px at 45% 75%, rgba(167,139,250,.48), transparent 62%),
        rgba(255,255,255,.06);
      box-shadow: var(--shadow);
    }
    .brand h1{ margin:0; font-size:16px; font-weight:900; letter-spacing:.2px; }
    .brand p{ margin:0; font-size:12px; color: var(--muted); }

    .top-actions{ display:flex; gap:8px; flex-wrap: wrap; align-items:center; }

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.07);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 800;
      font-size: 13px;
      letter-spacing:.15px;
      cursor:pointer;
      transition: transform var(--anim), background var(--anim), border-color var(--anim);
      box-shadow: 0 10px 22px rgba(0,0,0,.16);
    }
    .btn:hover{ background: rgba(255,255,255,.11); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0); }
    .btn:focus-visible{ outline: var(--focus); outline-offset:2px; }
    .btn.primary{
      border-color: rgba(125,211,252,.55);
      background: linear-gradient(180deg, rgba(125,211,252,.20), rgba(255,255,255,.06));
    }
    .btn.ghost{ background: transparent; box-shadow:none; }
    .btn.danger{
      border-color: rgba(251,113,133,.55);
      background: linear-gradient(180deg, rgba(251,113,133,.18), rgba(255,255,255,.06));
    }
    .btn.small{ padding: 8px 10px; border-radius: 12px; font-size: 12px; }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 920px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      border:1px solid var(--line);
      background: linear-gradient(180deg, var(--panel), transparent 140%);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow: clip;
    }
    .card .hd{
      padding: 14px 14px 10px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    .title{ display:flex; flex-direction:column; gap:3px; min-width: 0; }
    .title b{ font-size:14px; letter-spacing:.2px; }
    .title span{ font-size:12px; color: var(--muted); }
    .card .bd{ padding: 14px; }

    .row{ display:flex; align-items:center; gap:10px; flex-wrap: wrap; }
    .col{ display:flex; flex-direction:column; gap:10px; }
    .grow{ flex:1 1 auto; min-width: 220px; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      user-select:none;
      white-space: nowrap;
    }
    .pill strong{ color: var(--text); font-weight: 900; }

    .notice{
      border-radius: 18px;
      border: 1px dashed rgba(125,211,252,.35);
      background: rgba(125,211,252,.08);
      padding: 10px 12px;
      font-size: 12.5px;
      color: var(--muted);
    }

    label{ font-size:12px; color: var(--muted); display:block; margin-bottom:6px; }
    .input{
      width:100%;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      outline:none;
    }
    .input:focus{
      border-color: rgba(125,211,252,.55);
      background: rgba(255,255,255,.07);
    }

    .hr{ height:1px; background: var(--line); margin: 10px 0; }

    .dial{
      width: min(100%, 560px);
      border-radius: 22px;
      border: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: var(--shadow2);
      padding: 14px 12px 10px;
      position: relative;
      overflow: hidden;
    }
    .dial::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(700px 260px at 50% 110%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(320px 240px at 12% 0%, rgba(125,211,252,.08), transparent 65%),
        radial-gradient(340px 260px at 88% 0%, rgba(167,139,250,.08), transparent 65%);
      opacity:.9;
    }
    .dialInner{ position: relative; z-index: 1; }
    .dialSvg{ width: 100%; height: auto; display:block; }

    .dialLabels{
      display:flex;
      align-items:flex-end;
      justify-content: space-between;
      gap: 10px;
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .dialLabels .side{
      max-width: 46%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .dialLabels .mid{ font-weight: 900; color: rgba(255,255,255,.55); }
    @media (prefers-color-scheme: light){
      .dialLabels .mid{ color: rgba(0,0,0,.45); }
    }

    .legend{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content:center;
      font-size: 12px;
      color: var(--muted);
    }
    .lg{
      display:inline-flex;
      gap: 8px;
      align-items:center;
      padding: 6px 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
    }
    .sw{ width: 12px; height: 12px; border-radius: 4px; display:inline-block; }
    .sw.w2{ background: var(--dialWindow2); }
    .sw.w3{ background: var(--dialWindow3); }
    .sw.w4{ background: var(--dialWindow4); }

    .sliderRow{
      width: min(100%, 560px);
      display:flex;
      flex-direction: column;
      gap: 8px;
      margin: 0 auto;
    }
    input[type="range"]{ width:100%; accent-color: #7dd3fc; }
    .numRow{
      display:flex; justify-content: space-between; align-items:center;
      font-size: 12px; color: var(--muted);
    }
    .numRow b{ color: var(--text); font-weight: 900; }

    .playerBox{
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 8px;
    }
    .playerTop{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .nameRow{ display:flex; align-items:center; gap:10px; min-width:0; }
    .dot{ width:10px; height:10px; border-radius:50%; background: var(--p1); }
    .dot.p2{ background: var(--p2); }
    .pname{ font-size: 13px; font-weight: 900; white-space: nowrap; overflow:hidden; text-overflow: ellipsis; }
    .pscore{ font-size: 24px; font-weight: 950; letter-spacing:.2px; }
    .role{
      font-size: 12px; color: var(--muted);
      display:flex; justify-content: space-between; align-items:center; gap: 10px;
    }
    .role b{ color: var(--text); }

    .modalBackdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 50;
    }
    .modalBackdrop.show{ display:flex; }
    .modal{
      width:min(820px, 100%);
      max-height: min(86vh, 720px);
      overflow:auto;
      border-radius: 22px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      box-shadow: var(--shadow2);
    }
    .modal .mhd{
      padding: 14px 14px 10px;
      display:flex; align-items:center; justify-content: space-between; gap:10px;
      border-bottom:1px solid var(--line);
      position: sticky; top:0;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(0,0,0,.22), transparent);
    }
    @media (prefers-color-scheme: light){
      .modal .mhd{ background: linear-gradient(180deg, rgba(255,255,255,.72), rgba(255,255,255,.24)); }
    }
    .modal .mbd{ padding: 14px; }
    .modal h3{ margin:10px 0 6px; font-size: 13px; }
    .modal li{ font-size: 12.5px; color: var(--muted); }
    .modal ul{ margin: 8px 0 0 18px; padding: 0; }

    .toast{
      position: fixed;
      left:50%; bottom:18px;
      transform: translateX(-50%);
      max-width: min(760px, calc(100% - 24px));
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.55);
      color: rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow2);
      display:none;
      z-index: 80;
      font-size: 12.5px;
    }
    @media (prefers-color-scheme: light){
      .toast{ background: rgba(255,255,255,.84); color: rgba(0,0,0,.88); }
    }
    .toast.show{ display:block; animation: popIn 220ms cubic-bezier(.2,.8,.2,1); }
    @keyframes popIn{
      from{ transform: translateX(-50%) translateY(8px); opacity:0; }
      to{ transform: translateX(-50%) translateY(0); opacity:1; }
    }

    @media (prefers-reduced-motion: reduce){
      *{ transition:none !important; animation:none !important; }
    }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Wavelength para dos jugadores">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Wavelength</h1>
          <p>2 jugadores ‚Äî sin modos, listo para jugar.</p>
        </div>
      </div>
      <div class="top-actions">
        <button class="btn ghost small" id="btnRules" aria-haspopup="dialog" aria-controls="modalRules">Instrucciones</button>
        <button class="btn small" id="btnFullscreen">Pantalla completa</button>
        <button class="btn danger small" id="btnReset">Reset</button>
      </div>
    </header>

    <main class="grid">
      <section class="card" aria-label="Panel principal">
        <div class="hd">
          <div class="title">
            <b id="phaseTitle">Cargando‚Ä¶</b>
            <span id="phaseSubtitle">‚Äî</span>
          </div>
          <div class="row">
            <span class="pill" id="pillTurn"><strong>Turno:</strong> ‚Äî</span>
            <span class="pill" id="pillGoal"><strong>Objetivo:</strong> 10</span>
          </div>
        </div>
        <div class="bd" id="mainArea"></div>
      </section>

      <aside class="card" aria-label="Marcador">
        <div class="hd">
          <div class="title">
            <b>Marcador</b>
            <span id="scoreSubtitle">Primero a 10 puntos</span>
          </div>
          <div class="row">
            <button class="btn small" id="btnPass">Pasar dispositivo</button>
          </div>
        </div>
        <div class="bd">
          <div class="col">
            <div class="playerBox">
              <div class="playerTop">
                <div class="nameRow">
                  <span class="dot" aria-hidden="true"></span>
                  <div class="pname" id="p1Name">Jugador 1</div>
                </div>
                <div class="pscore" id="p1Score">0</div>
              </div>
              <div class="role">
                <span>Rol: <b id="p1Role">‚Äî</b></span>
                <span class="pill"><strong>ID:</strong> 1</span>
              </div>
            </div>

            <div class="playerBox">
              <div class="playerTop">
                <div class="nameRow">
                  <span class="dot p2" aria-hidden="true"></span>
                  <div class="pname" id="p2Name">Jugador 2</div>
                </div>
                <div class="pscore" id="p2Score">0</div>
              </div>
              <div class="role">
                <span>Rol: <b id="p2Role">‚Äî</b></span>
                <span class="pill"><strong>ID:</strong> 2</span>
              </div>
            </div>

            <div class="hr"></div>

            <div class="legend" aria-label="Leyenda de puntuaci√≥n">
              <span class="lg"><span class="sw w4"></span>4 pts ¬±5</span>
              <span class="lg"><span class="sw w3"></span>3 pts ¬±12</span>
              <span class="lg"><span class="sw w2"></span>2 pts ¬±20</span>
            </div>

            <div class="notice">
              Dial estilo ‚Äújuego f√≠sico‚Äù: ventana peque√±a con 2‚Äì3‚Äì4‚Äì3‚Äì2.
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <div class="modalBackdrop" id="modalRules" role="dialog" aria-modal="true" aria-labelledby="modalRulesTitle">
    <div class="modal">
      <div class="mhd">
        <b id="modalRulesTitle">Instrucciones (2 jugadores)</b>
        <button class="btn small" id="btnCloseRules">Cerrar</button>
      </div>
      <div class="mbd">
        <h3>Flujo</h3>
        <ul>
          <li><b>Nueva ronda:</b> carta (dos extremos) + pista opcional.</li>
          <li><b>Ps√≠quico:</b> un jugador ve el objetivo (0‚Äì100) y dice una pista.</li>
          <li><b>Adivinar:</b> el otro jugador mueve el dial (0‚Äì100) y bloquea.</li>
          <li><b>Revelaci√≥n:</b> se muestra el objetivo y se punt√∫a. Luego se intercambian roles.</li>
        </ul>

        <h3>Puntuaci√≥n</h3>
        <ul>
          <li>¬±5: <b>4 puntos</b></li>
          <li>¬±12: <b>3 puntos</b></li>
          <li>¬±20: <b>2 puntos</b></li>
          <li>Fuera: <b>0 puntos</b></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    (() => {
      "use strict";

      const CARDS = [
        { left:"Fr√≠o", right:"Caliente" },
        { left:"Aburrido", right:"Emocionante" },
        { left:"Inofensivo", right:"Peligroso" },
        { left:"Com√∫n", right:"Raro" },
        { left:"D√©bil", right:"Fuerte" },
        { left:"Simple", right:"Complejo" },
        { left:"Tradicional", right:"Innovador" },
        { left:"Caro", right:"Barato" },
        { left:"Serio", right:"C√≥mico" },
        { left:"Ordenado", right:"Ca√≥tico" },
        { left:"Ego√≠sta", right:"Altruista" },
        { left:"Lento", right:"R√°pido" },
        { left:"Seguro", right:"Arriesgado" },
        { left:"Formal", right:"Informal" },
        { left:"Amigable", right:"Hostil" },
        { left:"Sutil", right:"Exagerado" },
        { left:"F√°cil", right:"Dif√≠cil" },
        { left:"De mal gusto", right:"Elegante" },
        { left:"Relajante", right:"Estresante" },
        { left:"Predecible", right:"Impredecible" },
        { left:"Infantil", right:"Adulto" },
        { left:"Moderno", right:"Retro" },
        { left:"Realista", right:"Fant√°stico" },
        { left:"Optimista", right:"Pesimista" },
        { left:"Honesto", right:"Enga√±oso" },
        { left:"Conservador", right:"Rebelde" },
        { left:"Silencioso", right:"Ruidoso" },
        { left:"√çntimo", right:"P√∫blico" },
        { left:"Casual", right:"Solemne" },
        { left:"Suave", right:"Brusco" },
        { left:"Delicado", right:"Robusto" },
        { left:"Abstracto", right:"Concreto" },
        { left:"Limpio", right:"Sucio" },
        { left:"Natural", right:"Artificial" },
        { left:"Agradable", right:"Desagradable" },
        { left:"Racional", right:"Emocional" },
        { left:"Amable", right:"Cruel" },
        { left:"Flexible", right:"R√≠gido" },
        { left:"Minimalista", right:"Recargado" },
        { left:"Local", right:"Global" },
        { left:"Cl√°sico", right:"Vanguardista" },
        { left:"Tierno", right:"Intimidante" },
        { left:"Pr√°ctico", right:"Impr√°ctico" },
        { left:"Popular", right:"De nicho" },
        { left:"Cotidiano", right:"√âpico" },
        { left:"Atemporal", right:"De moda" },
        { left:"Aire libre", right:"Interior" },
        { left:"Individual", right:"En equipo" },
        { left:"Aventurero", right:"Cauteloso" },
        { left:"Directo", right:"Ambiguo" },
        { left:"Atractivo", right:"Repulsivo" },
        { left:"Futurista", right:"Antiguo" },
        { left:"Eficiente", right:"Ineficiente" },
        { left:"Duro", right:"Blando" },
        { left:"Sincero", right:"Diplom√°tico" },
        { left:"Exclusivo", right:"Inclusivo" },
        { left:"Intenso", right:"Ligero" },
        { left:"Fr√°gil", right:"Resistente" },
        { left:"Estable", right:"Vol√°til" },
        { left:"Met√≥dico", right:"Impulsivo" },
        { left:"Sano", right:"Indulgente" },
        { left:"L√≥gico", right:"Intuitivo" },
        { left:"Pulido", right:"Desali√±ado" },
        { left:"Cercano", right:"Distante" },
        { left:"Profesional", right:"Amateur" },
        { left:"Humilde", right:"Presumido" },
        { left:"Confiable", right:"Inestable" },
        { left:"Cient√≠fico", right:"M√≠stico" },
        { left:"Transparente", right:"Opaco" },
        { left:"Carism√°tico", right:"Insulso" },
        { left:"Valiente", right:"Cobarde" },
        { left:"Curioso", right:"Indiferente" },
        { left:"Creativo", right:"Convencional" },
      ];

      const GOAL = 10;
      const WEDGES = { w4: 5, w3: 12, w2: 20 };

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

      // Value 0..100 -> radians on upper semicircle
      // 0 = left (œÄ), 50 = up (œÄ/2), 100 = right (0)
      function valueToRad(v){
        const x = clamp(v,0,100)/100;
        return Math.PI * (1 - x);
      }

      function randomTarget(){ return rnd(0, 100); }

      function scoreGuess(target, guess){
        const d = Math.abs(clamp(target,0,100) - clamp(guess,0,100));
        if (d <= WEDGES.w4) return { pts: 4, band: "CENTER" };
        if (d <= WEDGES.w3) return { pts: 3, band: "NEAR" };
        if (d <= WEDGES.w2) return { pts: 2, band: "FAR" };
        return { pts: 0, band: "MISS" };
      }

      const STATES = Object.freeze({
        SETUP: "SETUP",
        ROUND: "ROUND",
        PSYCHIC: "PSYCHIC",
        GUESS: "GUESS",
        REVEAL: "REVEAL",
        OVER: "OVER"
      });

      const $ = (sel, root=document) => root.querySelector(sel);

      const els = {
        main: $("#mainArea"),
        phaseTitle: $("#phaseTitle"),
        phaseSubtitle: $("#phaseSubtitle"),
        pillTurn: $("#pillTurn"),
        pillGoal: $("#pillGoal"),
        scoreSubtitle: $("#scoreSubtitle"),

        p1Name: $("#p1Name"),
        p2Name: $("#p2Name"),
        p1Score: $("#p1Score"),
        p2Score: $("#p2Score"),
        p1Role: $("#p1Role"),
        p2Role: $("#p2Role"),

        btnRules: $("#btnRules"),
        modalRules: $("#modalRules"),
        btnCloseRules: $("#btnCloseRules"),

        btnFullscreen: $("#btnFullscreen"),
        btnReset: $("#btnReset"),
        btnPass: $("#btnPass"),
        toast: $("#toast")
      };

      function showToast(msg, ms=2300){
        els.toast.textContent = msg;
        els.toast.classList.add("show");
        clearTimeout(showToast._t);
        showToast._t = setTimeout(() => els.toast.classList.remove("show"), ms);
      }

      function openModal(m){ m.classList.add("show"); m.querySelector("button")?.focus(); }
      function closeModal(m){ m.classList.remove("show"); }

      const store = {
        state: STATES.SETUP,
        goal: GOAL,
        players: [
          { name: "Jugador 1", score: 0 },
          { name: "Jugador 2", score: 0 }
        ],
        psychicIndex: 0,
        card: null,
        clue: "",
        target: null,
        guess: 50,
        scored: null,
        deck: []
      };

      function buildDeck(){
        store.deck = Array.from({length: CARDS.length}, (_,i)=>i);
        for (let i=store.deck.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [store.deck[i], store.deck[j]] = [store.deck[j], store.deck[i]];
        }
      }

      function drawCard(){
        if (store.deck.length === 0) buildDeck();
        const idx = store.deck.pop();
        return CARDS[idx];
      }

      function resetRound(){
        store.card = drawCard();
        store.clue = "";
        store.target = null;
        store.guess = 50;
        store.scored = null;
      }

      function setPhase(title, subtitle){
        els.phaseTitle.textContent = title;
        els.phaseSubtitle.textContent = subtitle;
      }

      function renderSidebar(){
        els.pillGoal.innerHTML = `<strong>Objetivo:</strong> ${store.goal}`;
        const psychic = store.psychicIndex;

        els.p1Name.textContent = store.players[0].name;
        els.p2Name.textContent = store.players[1].name;
        els.p1Score.textContent = store.players[0].score;
        els.p2Score.textContent = store.players[1].score;

        const roles = (store.state === STATES.SETUP || store.state === STATES.OVER)
          ? ["‚Äî","‚Äî"]
          : [
              psychic === 0 ? "Ps√≠quico" : "Adivina",
              psychic === 1 ? "Ps√≠quico" : "Adivina"
            ];

        els.p1Role.textContent = roles[0];
        els.p2Role.textContent = roles[1];

        const turnText = (store.state === STATES.SETUP || store.state === STATES.OVER)
          ? "‚Äî"
          : `${store.players[psychic].name} (Ps√≠quico)`;
        els.pillTurn.innerHTML = `<strong>Turno:</strong> ${turnText}`;

        els.scoreSubtitle.textContent = `Primero a ${store.goal} puntos`;
      }

      function escapeHtml(s){
        return String(s).replace(/[&<>"']/g, m => ({
          "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
        }[m]));
      }

      function polarPoint(cx, cy, r, rad){
        return { x: cx + Math.cos(rad)*r, y: cy - Math.sin(rad)*r };
      }

      function donutSectorPath(cx, cy, rOuter, rInner, startRad, endRad){
        const p1o = polarPoint(cx, cy, rOuter, startRad);
        const p2o = polarPoint(cx, cy, rOuter, endRad);
        const p2i = polarPoint(cx, cy, rInner, endRad);
        const p1i = polarPoint(cx, cy, rInner, startRad);

        const delta = Math.abs(endRad - startRad);
        const largeArc = delta > Math.PI ? 1 : 0;

        return [
          `M ${p1o.x.toFixed(2)} ${p1o.y.toFixed(2)}`,
          `A ${rOuter} ${rOuter} 0 ${largeArc} 1 ${p2o.x.toFixed(2)} ${p2o.y.toFixed(2)}`,
          `L ${p2i.x.toFixed(2)} ${p2i.y.toFixed(2)}`,
          `A ${rInner} ${rInner} 0 ${largeArc} 0 ${p1i.x.toFixed(2)} ${p1i.y.toFixed(2)}`,
          "Z"
        ].join(" ");
      }

      function needleLineSVG(value, r1, r2, stroke, strokeWidth, opacity=1){
        const cx=200, cy=200;
        const rad = valueToRad(value);
        const p1 = polarPoint(cx, cy, r1, rad);
        const p2 = polarPoint(cx, cy, r2, rad);
        return `<line x1="${p1.x.toFixed(2)}" y1="${p1.y.toFixed(2)}" x2="${p2.x.toFixed(2)}" y2="${p2.y.toFixed(2)}" stroke="${stroke}" stroke-width="${strokeWidth}" stroke-linecap="round" opacity="${opacity}"></line>`;
      }

      // Visual window like the physical game:
      // A fixed small fan (not centered on the target) and five discrete slices 2‚Äì3‚Äì4‚Äì3‚Äì2.
      // The *scoring logic* still uses ¬±5/¬±12/¬±20 around target (unchanged).
      function scoringFanSVG(targetVal){
        const cx=200, cy=200;

        // Fan placement: anchored near the left side like the photo.
        // We'll render it in the arc region between angles ~150¬∞ to ~110¬∞ (in our rad system: œÄ is left, 0 is right).
        // That corresponds to radians around [~2.62 .. ~1.92]. We'll define as "fanStartRad .. fanEndRad".
        const fanStartRad = 2.62; // ~150¬∞
        const fanEndRad   = 2.02; // ~116¬∞
        const fanMidRad = (fanStartRad + fanEndRad)/2;

        // Donut thickness to mimic plastic window
        const rOuter = 160;
        const rInner = 85;

        // Five slices arranged contiguous inside the fan: 2-3-4-3-2
        // Make the center slice (4) a bit wider visually than the 3s, and 2s slightly wider than 3s
        // to match the "fan" look. (Visual only; scoring stays correct.)
        const totalSpan = Math.abs(fanEndRad - fanStartRad);
        const weights = [1.15, 0.95, 1.05, 0.95, 1.15];
        const wsum = weights.reduce((a,b)=>a+b,0);
        const spans = weights.map(w => totalSpan*(w/wsum));

        const slices = [];
        let cur = fanStartRad;

        const colors = [
          "var(--dialWindow2)",
          "var(--dialWindow3)",
          "var(--dialWindow4)",
          "var(--dialWindow3)",
          "var(--dialWindow2)"
        ];
        const labels = ["2","3","4","3","2"];

        for (let i=0;i<5;i++){
          const next = cur - spans[i]; // move "towards up" (smaller rad)
          const s = cur;
          const e = next;
          const path = donutSectorPath(cx, cy, rOuter, rInner, s, e);

          const mid = (s+e)/2;
          const p = polarPoint(cx, cy, (rOuter+rInner)/2 + 2, mid);

          slices.push(`
            <path d="${path}" fill="${colors[i]}" opacity="0.95"></path>
            <text x="${p.x.toFixed(2)}" y="${p.y.toFixed(2)}"
                  text-anchor="middle" dominant-baseline="middle"
                  font-size="14" font-weight="900"
                  fill="var(--dialTextDark)">
              ${labels[i]}
            </text>
          `);

          cur = next;
        }

        // Visual highlight: a subtle outline and a tiny pointer line marking the actual target (optional)
        // We'll draw a thin line pointing to the target value, but only in reveal/psychic.
        const tRad = valueToRad(targetVal);
        const tP1 = polarPoint(cx, cy, 200, tRad);
        const tP2 = polarPoint(cx, cy, rInner-6, tRad);

        return `
          <g>
            <!-- Subtle shadow behind fan -->
            <path d="${donutSectorPath(cx, cy, rOuter+1, rInner-1, fanStartRad, fanEndRad)}"
                  fill="rgba(0,0,0,.08)"></path>

            <!-- Fan slices -->
            ${slices.join("")}

            <!-- Fan outline -->
            <path d="${donutSectorPath(cx, cy, rOuter, rInner, fanStartRad, fanEndRad)}"
                  fill="none" stroke="rgba(0,0,0,.22)" stroke-width="1"></path>

            <!-- (Optional) target marker line, subtle -->
            <line x1="${tP1.x.toFixed(2)}" y1="${tP1.y.toFixed(2)}"
                  x2="${tP2.x.toFixed(2)}" y2="${tP2.y.toFixed(2)}"
                  stroke="rgba(0,0,0,.22)" stroke-width="2" stroke-linecap="round" opacity="0.35"></line>
          </g>
        `;
      }

      function dialHTML({ left, right, showTarget, target, showGuess, guess }){
        const t = target ?? 50;
        const g = guess ?? 50;

        // Half-disc face path
        const halfDisc = `M 40 200 A 160 160 0 0 1 360 200 L 200 200 Z`;

        return `
          <div class="dial">
            <div class="dialInner">
              <svg class="dialSvg" viewBox="0 0 400 250" aria-label="Dial Wavelength" role="img">
                <defs>
                  <filter id="softShadow" x="-50%" y="-50%" width="200%" height="200%">
                    <feDropShadow dx="0" dy="10" stdDeviation="10" flood-color="rgba(0,0,0,.25)"/>
                  </filter>
                </defs>

                <!-- Face (filled semicircle like the physical board) -->
                <g filter="url(#softShadow)">
                  <path d="${halfDisc}" fill="var(--dialFace)" stroke="var(--dialFaceEdge)" stroke-width="2"></path>
                </g>

                <!-- Ticks (very subtle, like engraved) -->
                ${
                  Array.from({length: 21}, (_,i)=>{
                    const v = i*5;
                    const rad = valueToRad(v);
                    const r1 = 154;
                    const r2 = (i%5===0) ? 138 : 146;
                    const p1 = polarPoint(200, 200, r1, rad);
                    const p2 = polarPoint(200, 200, r2, rad);
                    const sw = (i%5===0) ? 2.2 : 1.2;
                    const op = (i%5===0) ? .16 : .10;
                    return `<line x1="${p1.x.toFixed(2)}" y1="${p1.y.toFixed(2)}" x2="${p2.x.toFixed(2)}" y2="${p2.y.toFixed(2)}" stroke="rgba(0,0,0,${op})" stroke-width="${sw}" />`;
                  }).join("")
                }

                <!-- Scoring fan (only when target visible) -->
                ${showTarget ? scoringFanSVG(t) : ""}

                <!-- Guess needle (red, like the physical pointer) -->
                ${showGuess ? `
                  <g filter="url(#softShadow)">
                    ${needleLineSVG(g, 200, 52, "var(--dialNeedle)", 7, 0.95)}
                    ${needleLineSVG(g, 200, 58, "var(--dialNeedle2)", 3, 0.55)}
                  </g>
                ` : ""}

                <!-- Center knob (big red circle) -->
                <g filter="url(#softShadow)">
                  <circle cx="200" cy="200" r="58" fill="var(--dialCenter)"></circle>
                  <circle cx="200" cy="200" r="58" fill="none" stroke="rgba(0,0,0,.18)" stroke-width="2"></circle>
                  <circle cx="200" cy="200" r="20" fill="rgba(255,255,255,.12)"></circle>
                </g>
              </svg>

              <div class="dialLabels" aria-hidden="true">
                <div class="side">${escapeHtml(left)}</div>
                <div class="mid">${showTarget ? `Obj: ${t}` : `0‚Äì100`}</div>
                <div class="side" style="text-align:right;">${escapeHtml(right)}</div>
              </div>
            </div>
          </div>
        `;
      }

      function render(){
        renderSidebar();
        const s = store.state;

        if (s === STATES.SETUP){
          setPhase("Listo para jugar", "Pon nombres (opcional) y pulsa Empezar.");
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="row">
                <div class="grow">
                  <label for="inpP1">Nombre Jugador 1</label>
                  <input id="inpP1" class="input" value="${escapeHtml(store.players[0].name)}" />
                </div>
                <div class="grow">
                  <label for="inpP2">Nombre Jugador 2</label>
                  <input id="inpP2" class="input" value="${escapeHtml(store.players[1].name)}" />
                </div>
              </div>

              <div class="notice">
                <b>C√≥mo se juega:</b> el Ps√≠quico ve el objetivo y da una pista. El otro ajusta el dial. Se alternan roles cada ronda.
              </div>

              ${dialHTML({
                left:"Extremo izquierdo",
                right:"Extremo derecho",
                showTarget:false,
                target:null,
                showGuess:true,
                guess: 50
              })}

              <div class="row" style="justify-content:space-between;">
                <span class="pill"><strong>Cartas:</strong> ${CARDS.length}</span>
                <button class="btn primary" id="btnStart">Empezar</button>
              </div>
            </div>
          `;

          $("#inpP1").addEventListener("input", (e)=>{ store.players[0].name = (e.target.value||"").trim() || "Jugador 1"; renderSidebar(); });
          $("#inpP2").addEventListener("input", (e)=>{ store.players[1].name = (e.target.value||"").trim() || "Jugador 2"; renderSidebar(); });

          $("#btnStart").addEventListener("click", () => {
            store.players[0].score = 0;
            store.players[1].score = 0;
            store.psychicIndex = 0;
            buildDeck();
            resetRound();
            store.state = STATES.ROUND;
            showToast("Ronda 1: el Ps√≠quico prepara la pista.");
            render();
          });
          return;
        }

        if (s === STATES.ROUND){
          const psychic = store.psychicIndex;
          setPhase("Nueva ronda", `${store.players[psychic].name} es Ps√≠quico. Selecciona carta y (opcional) escribe la pista.`);
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="row" style="justify-content:space-between; align-items:flex-start;">
                <div class="col" style="gap:6px;">
                  <b style="font-size:14px;">Carta</b>
                  <span class="pill"><strong>${escapeHtml(store.card.left)}</strong> ‚Äî <strong>${escapeHtml(store.card.right)}</strong></span>
                </div>
                <div class="row">
                  <button class="btn" id="btnNewCard">Otra carta</button>
                </div>
              </div>

              ${dialHTML({
                left: store.card.left,
                right: store.card.right,
                showTarget:false,
                target:null,
                showGuess:true,
                guess: 50
              })}

              <div class="row">
                <div class="grow">
                  <label for="inpClue">Pista (opcional, se mostrar√° tras la revelaci√≥n)</label>
                  <input id="inpClue" class="input" value="${escapeHtml(store.clue)}" placeholder="Ej: ‚Äútostadora‚Äù, ‚Äúdomingo de resaca‚Äù‚Ä¶"/>
                </div>
              </div>

              <div class="row" style="justify-content:space-between;">
                <button class="btn" id="btnPassToPsychic">Ir a Ps√≠quico (mostrar objetivo)</button>
                <button class="btn primary" id="btnGoPsychic">Estoy listo</button>
              </div>
            </div>
          `;

          $("#btnNewCard").addEventListener("click", () => {
            resetRound();
            showToast("Carta nueva.");
            render();
          });

          $("#inpClue").addEventListener("input", (e)=>{
            store.clue = (e.target.value||"").trim().slice(0, 140);
          });

          $("#btnPassToPsychic").addEventListener("click", () => {
            showToast("‚ö†Ô∏è Solo el Ps√≠quico debe mirar ahora.");
          });

          $("#btnGoPsychic").addEventListener("click", () => {
            store.target = randomTarget();
            store.state = STATES.PSYCHIC;
            showToast("Objetivo generado. Solo el Ps√≠quico mira.");
            render();
          });
          return;
        }

        if (s === STATES.PSYCHIC){
          const psychic = store.psychicIndex;
          setPhase("Ps√≠quico", `${store.players[psychic].name}: mira el objetivo y di la pista. Luego oculta y pasa el dispositivo.`);
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="notice">
                <b>Solo el Ps√≠quico</b>. No uses n√∫meros. Una sola idea. Cuando termines, pulsa <b>Ocultar objetivo</b>.
              </div>

              ${dialHTML({
                left: store.card.left,
                right: store.card.right,
                showTarget:true,
                target: store.target,
                showGuess:false,
                guess: store.guess
              })}

              <div class="row">
                <div class="grow">
                  <label for="inpClue2">Pista (opcional, para recordarla)</label>
                  <input id="inpClue2" class="input" value="${escapeHtml(store.clue)}" placeholder="(Opcional) escribe la pista que has dicho"/>
                </div>
              </div>

              <div class="row" style="justify-content:space-between;">
                <button class="btn" id="btnBackRound">Volver</button>
                <button class="btn primary" id="btnHide">Ocultar objetivo / Pasar al otro jugador</button>
              </div>
            </div>
          `;

          $("#inpClue2").addEventListener("input", (e)=>{
            store.clue = (e.target.value||"").trim().slice(0, 140);
          });

          $("#btnBackRound").addEventListener("click", () => {
            if (!confirm("¬øVolver a Nueva ronda? Se regenerar√° el objetivo al volver a Ps√≠quico.")) return;
            store.target = null;
            store.state = STATES.ROUND;
            render();
          });

          $("#btnHide").addEventListener("click", () => {
            store.state = STATES.GUESS;
            showToast("Ahora adivina el otro jugador (sin objetivo).");
            render();
          });
          return;
        }

        if (s === STATES.GUESS){
          const psychic = store.psychicIndex;
          const guesser = 1 - psychic;
          setPhase("Adivinar", `${store.players[guesser].name}: ajusta el dial (0‚Äì100) y bloquea tu respuesta.`);
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="notice">
                Objetivo oculto. Ajusta la posici√≥n. Cuando est√©s seguro, bloquea.
              </div>

              ${dialHTML({
                left: store.card.left,
                right: store.card.right,
                showTarget:false,
                target:null,
                showGuess:true,
                guess: store.guess
              })}

              <div class="sliderRow">
                <label for="rngGuess">Posici√≥n (0‚Äì100)</label>
                <input id="rngGuess" type="range" min="0" max="100" value="${store.guess}" aria-label="Selector de posici√≥n"/>
                <div class="numRow">
                  <span>0</span>
                  <span>Actual: <b id="gVal">${store.guess}</b></span>
                  <span>100</span>
                </div>
              </div>

              <div class="row" style="justify-content:space-between;">
                <button class="btn" id="btnBackPsychic">Volver (Ps√≠quico)</button>
                <button class="btn primary" id="btnLock">Bloquear y revelar</button>
              </div>
            </div>
          `;

          const rng = $("#rngGuess");
          const gVal = $("#gVal");

          rng.addEventListener("input", () => {
            store.guess = clamp(parseInt(rng.value,10), 0, 100);
            gVal.textContent = store.guess;
            render();
            store.state = STATES.GUESS;
          });

          $("#btnBackPsychic").addEventListener("click", () => {
            if (!confirm("¬øVolver a Ps√≠quico? Aseg√∫rate de que solo el Ps√≠quico mire.")) return;
            store.state = STATES.PSYCHIC;
            render();
          });

          $("#btnLock").addEventListener("click", () => {
            if (!confirm(`¬øBloquear ${store.guess}?`)) return;
            store.scored = scoreGuess(store.target, store.guess);
            store.state = STATES.REVEAL;
            render();
          });
          return;
        }

        if (s === STATES.REVEAL){
          const psychic = store.psychicIndex;
          const guesser = 1 - psychic;

          const pts = store.scored?.pts ?? 0;
          setPhase("Revelaci√≥n", `Objetivo: ${store.target} ¬∑ Posici√≥n: ${store.guess} ¬∑ +${pts} puntos para ${store.players[guesser].name}`);

          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              ${dialHTML({
                left: store.card.left,
                right: store.card.right,
                showTarget:true,
                target: store.target,
                showGuess:true,
                guess: store.guess
              })}

              <div class="row">
                <span class="pill"><strong>Objetivo:</strong> ${store.target}</span>
                <span class="pill"><strong>Posici√≥n:</strong> ${store.guess}</span>
                <span class="pill"><strong>Puntos:</strong> +${pts}</span>
              </div>

              <div class="notice">
                <b>Carta:</b> ${escapeHtml(store.card.left)} ‚Äî ${escapeHtml(store.card.right)}<br/>
                <b>Pista:</b> ${escapeHtml(store.clue || "‚Äî")}
              </div>

              <div class="row" style="justify-content:space-between;">
                <button class="btn" id="btnBackGuess">Volver (Adivinar)</button>
                <button class="btn primary" id="btnNext">Siguiente ronda (cambiar roles)</button>
              </div>
            </div>
          `;

          $("#btnBackGuess").addEventListener("click", () => {
            if (!confirm("¬øVolver a Adivinar? Mantendr√°s el mismo objetivo.")) return;
            store.state = STATES.GUESS;
            render();
          });

          $("#btnNext").addEventListener("click", () => {
            store.players[guesser].score += pts;

            if (store.players[0].score >= store.goal || store.players[1].score >= store.goal){
              store.state = STATES.OVER;
              render();
              showToast("Fin de partida.");
              return;
            }

            store.psychicIndex = 1 - store.psychicIndex;
            resetRound();
            store.state = STATES.ROUND;
            showToast("Roles cambiados. Nueva ronda.");
            render();
          });
          return;
        }

        if (s === STATES.OVER){
          const s1 = store.players[0].score;
          const s2 = store.players[1].score;
          const winner = s1 === s2 ? "Empate" : (s1 > s2 ? store.players[0].name : store.players[1].name);

          setPhase("Fin de partida", winner === "Empate" ? "Empate." : `Ganador: ${winner}`);
          els.main.innerHTML = `
            <div class="col" style="gap:14px;">
              <div class="notice">
                <b style="font-size:14px;">Resultado</b><br/>
                <div style="margin-top:10px" class="row">
                  <span class="pill"><strong>${escapeHtml(store.players[0].name)}:</strong> ${s1}</span>
                  <span class="pill"><strong>${escapeHtml(store.players[1].name)}:</strong> ${s2}</span>
                </div>
              </div>

              ${dialHTML({
                left:"‚Äî",
                right:"‚Äî",
                showTarget:false,
                target:null,
                showGuess:true,
                guess: 50
              })}

              <div class="row" style="justify-content:center;">
                <button class="btn primary" id="btnPlayAgain">Jugar otra vez</button>
                <button class="btn" id="btnBackSetup">Cambiar nombres</button>
              </div>
            </div>
          `;

          $("#btnPlayAgain").addEventListener("click", () => {
            store.players[0].score = 0;
            store.players[1].score = 0;
            store.psychicIndex = 0;
            buildDeck();
            resetRound();
            store.state = STATES.ROUND;
            showToast("Nueva partida.");
            render();
          });

          $("#btnBackSetup").addEventListener("click", () => {
            store.state = STATES.SETUP;
            render();
          });
          return;
        }
      }

      els.btnRules.addEventListener("click", () => openModal(els.modalRules));
      els.btnCloseRules.addEventListener("click", () => closeModal(els.modalRules));
      els.modalRules.addEventListener("click", (e)=>{ if (e.target === els.modalRules) closeModal(els.modalRules); });
      window.addEventListener("keydown", (e)=>{ if (e.key === "Escape") closeModal(els.modalRules); });

      els.btnFullscreen.addEventListener("click", async () => {
        try{
          if (!document.fullscreenElement){
            await document.documentElement.requestFullscreen();
            showToast("Pantalla completa.");
          } else {
            await document.exitFullscreen();
            showToast("Salir de pantalla completa.");
          }
        } catch {
          showToast("Pantalla completa no disponible.");
        }
      });

      els.btnPass.addEventListener("click", () => {
        const msg =
          store.state === STATES.PSYCHIC ? "üì± Solo el PS√çQUICO mira ahora." :
          store.state === STATES.GUESS ? "üì± Ahora adivina el otro jugador (sin objetivo)." :
          store.state === STATES.REVEAL ? "üì± Revelaci√≥n: puede mirar todo el mundo." :
          "üì± Estado actual listo.";
        showToast(msg, 2600);
      });

      els.btnReset.addEventListener("click", () => {
        if (!confirm("¬øReset total? Reinicia puntuaci√≥n y vuelve al inicio.")) return;
        store.players[0].score = 0;
        store.players[1].score = 0;
        store.psychicIndex = 0;
        store.card = null;
        store.clue = "";
        store.target = null;
        store.guess = 50;
        store.scored = null;
        store.deck = [];
        store.state = STATES.SETUP;
        showToast("Reset completado.");
        render();
      });

      render();
    })();
  </script>
</body>
</html>
